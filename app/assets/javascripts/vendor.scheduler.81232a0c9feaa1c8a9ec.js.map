{"version":3,"file":"vendor.scheduler.81232a0c9feaa1c8a9ec.js","mappings":"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","sources":["webpack://Gwaphics/./node_modules/scheduler/cjs/scheduler-tracing.development.js","webpack://Gwaphics/./node_modules/scheduler/cjs/scheduler.development.js","webpack://Gwaphics/./node_modules/scheduler/index.js","webpack://Gwaphics/./node_modules/scheduler/tracing.js"],"sourcesContent":["/** @license React v0.19.1\n * scheduler-tracing.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\n\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function() {\n'use strict';\n\nvar DEFAULT_THREAD_ID = 0; // Counters used to generate unique IDs.\n\nvar interactionIDCounter = 0;\nvar threadIDCounter = 0; // Set of currently traced interactions.\n// Interactions \"stack\"–\n// Meaning that newly traced interactions are appended to the previously active set.\n// When an interaction goes out of scope, the previous set (if any) is restored.\n\nexports.__interactionsRef = null; // Listener(s) to notify when interactions begin and end.\n\nexports.__subscriberRef = null;\n\n{\n  exports.__interactionsRef = {\n    current: new Set()\n  };\n  exports.__subscriberRef = {\n    current: null\n  };\n}\nfunction unstable_clear(callback) {\n\n  var prevInteractions = exports.__interactionsRef.current;\n  exports.__interactionsRef.current = new Set();\n\n  try {\n    return callback();\n  } finally {\n    exports.__interactionsRef.current = prevInteractions;\n  }\n}\nfunction unstable_getCurrent() {\n  {\n    return exports.__interactionsRef.current;\n  }\n}\nfunction unstable_getThreadID() {\n  return ++threadIDCounter;\n}\nfunction unstable_trace(name, timestamp, callback) {\n  var threadID = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_THREAD_ID;\n\n  var interaction = {\n    __count: 1,\n    id: interactionIDCounter++,\n    name: name,\n    timestamp: timestamp\n  };\n  var prevInteractions = exports.__interactionsRef.current; // Traced interactions should stack/accumulate.\n  // To do that, clone the current interactions.\n  // The previous set will be restored upon completion.\n\n  var interactions = new Set(prevInteractions);\n  interactions.add(interaction);\n  exports.__interactionsRef.current = interactions;\n  var subscriber = exports.__subscriberRef.current;\n  var returnValue;\n\n  try {\n    if (subscriber !== null) {\n      subscriber.onInteractionTraced(interaction);\n    }\n  } finally {\n    try {\n      if (subscriber !== null) {\n        subscriber.onWorkStarted(interactions, threadID);\n      }\n    } finally {\n      try {\n        returnValue = callback();\n      } finally {\n        exports.__interactionsRef.current = prevInteractions;\n\n        try {\n          if (subscriber !== null) {\n            subscriber.onWorkStopped(interactions, threadID);\n          }\n        } finally {\n          interaction.__count--; // If no async work was scheduled for this interaction,\n          // Notify subscribers that it's completed.\n\n          if (subscriber !== null && interaction.__count === 0) {\n            subscriber.onInteractionScheduledWorkCompleted(interaction);\n          }\n        }\n      }\n    }\n  }\n\n  return returnValue;\n}\nfunction unstable_wrap(callback) {\n  var threadID = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_THREAD_ID;\n\n  var wrappedInteractions = exports.__interactionsRef.current;\n  var subscriber = exports.__subscriberRef.current;\n\n  if (subscriber !== null) {\n    subscriber.onWorkScheduled(wrappedInteractions, threadID);\n  } // Update the pending async work count for the current interactions.\n  // Update after calling subscribers in case of error.\n\n\n  wrappedInteractions.forEach(function (interaction) {\n    interaction.__count++;\n  });\n  var hasRun = false;\n\n  function wrapped() {\n    var prevInteractions = exports.__interactionsRef.current;\n    exports.__interactionsRef.current = wrappedInteractions;\n    subscriber = exports.__subscriberRef.current;\n\n    try {\n      var returnValue;\n\n      try {\n        if (subscriber !== null) {\n          subscriber.onWorkStarted(wrappedInteractions, threadID);\n        }\n      } finally {\n        try {\n          returnValue = callback.apply(undefined, arguments);\n        } finally {\n          exports.__interactionsRef.current = prevInteractions;\n\n          if (subscriber !== null) {\n            subscriber.onWorkStopped(wrappedInteractions, threadID);\n          }\n        }\n      }\n\n      return returnValue;\n    } finally {\n      if (!hasRun) {\n        // We only expect a wrapped function to be executed once,\n        // But in the event that it's executed more than once–\n        // Only decrement the outstanding interaction counts once.\n        hasRun = true; // Update pending async counts for all wrapped interactions.\n        // If this was the last scheduled async work for any of them,\n        // Mark them as completed.\n\n        wrappedInteractions.forEach(function (interaction) {\n          interaction.__count--;\n\n          if (subscriber !== null && interaction.__count === 0) {\n            subscriber.onInteractionScheduledWorkCompleted(interaction);\n          }\n        });\n      }\n    }\n  }\n\n  wrapped.cancel = function cancel() {\n    subscriber = exports.__subscriberRef.current;\n\n    try {\n      if (subscriber !== null) {\n        subscriber.onWorkCanceled(wrappedInteractions, threadID);\n      }\n    } finally {\n      // Update pending async counts for all wrapped interactions.\n      // If this was the last scheduled async work for any of them,\n      // Mark them as completed.\n      wrappedInteractions.forEach(function (interaction) {\n        interaction.__count--;\n\n        if (subscriber && interaction.__count === 0) {\n          subscriber.onInteractionScheduledWorkCompleted(interaction);\n        }\n      });\n    }\n  };\n\n  return wrapped;\n}\n\nvar subscribers = null;\n\n{\n  subscribers = new Set();\n}\n\nfunction unstable_subscribe(subscriber) {\n  {\n    subscribers.add(subscriber);\n\n    if (subscribers.size === 1) {\n      exports.__subscriberRef.current = {\n        onInteractionScheduledWorkCompleted: onInteractionScheduledWorkCompleted,\n        onInteractionTraced: onInteractionTraced,\n        onWorkCanceled: onWorkCanceled,\n        onWorkScheduled: onWorkScheduled,\n        onWorkStarted: onWorkStarted,\n        onWorkStopped: onWorkStopped\n      };\n    }\n  }\n}\nfunction unstable_unsubscribe(subscriber) {\n  {\n    subscribers.delete(subscriber);\n\n    if (subscribers.size === 0) {\n      exports.__subscriberRef.current = null;\n    }\n  }\n}\n\nfunction onInteractionTraced(interaction) {\n  var didCatchError = false;\n  var caughtError = null;\n  subscribers.forEach(function (subscriber) {\n    try {\n      subscriber.onInteractionTraced(interaction);\n    } catch (error) {\n      if (!didCatchError) {\n        didCatchError = true;\n        caughtError = error;\n      }\n    }\n  });\n\n  if (didCatchError) {\n    throw caughtError;\n  }\n}\n\nfunction onInteractionScheduledWorkCompleted(interaction) {\n  var didCatchError = false;\n  var caughtError = null;\n  subscribers.forEach(function (subscriber) {\n    try {\n      subscriber.onInteractionScheduledWorkCompleted(interaction);\n    } catch (error) {\n      if (!didCatchError) {\n        didCatchError = true;\n        caughtError = error;\n      }\n    }\n  });\n\n  if (didCatchError) {\n    throw caughtError;\n  }\n}\n\nfunction onWorkScheduled(interactions, threadID) {\n  var didCatchError = false;\n  var caughtError = null;\n  subscribers.forEach(function (subscriber) {\n    try {\n      subscriber.onWorkScheduled(interactions, threadID);\n    } catch (error) {\n      if (!didCatchError) {\n        didCatchError = true;\n        caughtError = error;\n      }\n    }\n  });\n\n  if (didCatchError) {\n    throw caughtError;\n  }\n}\n\nfunction onWorkStarted(interactions, threadID) {\n  var didCatchError = false;\n  var caughtError = null;\n  subscribers.forEach(function (subscriber) {\n    try {\n      subscriber.onWorkStarted(interactions, threadID);\n    } catch (error) {\n      if (!didCatchError) {\n        didCatchError = true;\n        caughtError = error;\n      }\n    }\n  });\n\n  if (didCatchError) {\n    throw caughtError;\n  }\n}\n\nfunction onWorkStopped(interactions, threadID) {\n  var didCatchError = false;\n  var caughtError = null;\n  subscribers.forEach(function (subscriber) {\n    try {\n      subscriber.onWorkStopped(interactions, threadID);\n    } catch (error) {\n      if (!didCatchError) {\n        didCatchError = true;\n        caughtError = error;\n      }\n    }\n  });\n\n  if (didCatchError) {\n    throw caughtError;\n  }\n}\n\nfunction onWorkCanceled(interactions, threadID) {\n  var didCatchError = false;\n  var caughtError = null;\n  subscribers.forEach(function (subscriber) {\n    try {\n      subscriber.onWorkCanceled(interactions, threadID);\n    } catch (error) {\n      if (!didCatchError) {\n        didCatchError = true;\n        caughtError = error;\n      }\n    }\n  });\n\n  if (didCatchError) {\n    throw caughtError;\n  }\n}\n\nexports.unstable_clear = unstable_clear;\nexports.unstable_getCurrent = unstable_getCurrent;\nexports.unstable_getThreadID = unstable_getThreadID;\nexports.unstable_subscribe = unstable_subscribe;\nexports.unstable_trace = unstable_trace;\nexports.unstable_unsubscribe = unstable_unsubscribe;\nexports.unstable_wrap = unstable_wrap;\n  })();\n}\n","/** @license React v0.19.1\n * scheduler.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\n\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function() {\n'use strict';\n\nvar enableSchedulerDebugging = false;\nvar enableProfiling = true;\n\nvar requestHostCallback;\nvar requestHostTimeout;\nvar cancelHostTimeout;\nvar shouldYieldToHost;\nvar requestPaint;\n\nif ( // If Scheduler runs in a non-DOM environment, it falls back to a naive\n// implementation using setTimeout.\ntypeof window === 'undefined' || // Check if MessageChannel is supported, too.\ntypeof MessageChannel !== 'function') {\n  // If this accidentally gets imported in a non-browser environment, e.g. JavaScriptCore,\n  // fallback to a naive implementation.\n  var _callback = null;\n  var _timeoutID = null;\n\n  var _flushCallback = function () {\n    if (_callback !== null) {\n      try {\n        var currentTime = exports.unstable_now();\n        var hasRemainingTime = true;\n\n        _callback(hasRemainingTime, currentTime);\n\n        _callback = null;\n      } catch (e) {\n        setTimeout(_flushCallback, 0);\n        throw e;\n      }\n    }\n  };\n\n  var initialTime = Date.now();\n\n  exports.unstable_now = function () {\n    return Date.now() - initialTime;\n  };\n\n  requestHostCallback = function (cb) {\n    if (_callback !== null) {\n      // Protect against re-entrancy.\n      setTimeout(requestHostCallback, 0, cb);\n    } else {\n      _callback = cb;\n      setTimeout(_flushCallback, 0);\n    }\n  };\n\n  requestHostTimeout = function (cb, ms) {\n    _timeoutID = setTimeout(cb, ms);\n  };\n\n  cancelHostTimeout = function () {\n    clearTimeout(_timeoutID);\n  };\n\n  shouldYieldToHost = function () {\n    return false;\n  };\n\n  requestPaint = exports.unstable_forceFrameRate = function () {};\n} else {\n  // Capture local references to native APIs, in case a polyfill overrides them.\n  var performance = window.performance;\n  var _Date = window.Date;\n  var _setTimeout = window.setTimeout;\n  var _clearTimeout = window.clearTimeout;\n\n  if (typeof console !== 'undefined') {\n    // TODO: Scheduler no longer requires these methods to be polyfilled. But\n    // maybe we want to continue warning if they don't exist, to preserve the\n    // option to rely on it in the future?\n    var requestAnimationFrame = window.requestAnimationFrame;\n    var cancelAnimationFrame = window.cancelAnimationFrame; // TODO: Remove fb.me link\n\n    if (typeof requestAnimationFrame !== 'function') {\n      // Using console['error'] to evade Babel and ESLint\n      console['error'](\"This browser doesn't support requestAnimationFrame. \" + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');\n    }\n\n    if (typeof cancelAnimationFrame !== 'function') {\n      // Using console['error'] to evade Babel and ESLint\n      console['error'](\"This browser doesn't support cancelAnimationFrame. \" + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');\n    }\n  }\n\n  if (typeof performance === 'object' && typeof performance.now === 'function') {\n    exports.unstable_now = function () {\n      return performance.now();\n    };\n  } else {\n    var _initialTime = _Date.now();\n\n    exports.unstable_now = function () {\n      return _Date.now() - _initialTime;\n    };\n  }\n\n  var isMessageLoopRunning = false;\n  var scheduledHostCallback = null;\n  var taskTimeoutID = -1; // Scheduler periodically yields in case there is other work on the main\n  // thread, like user events. By default, it yields multiple times per frame.\n  // It does not attempt to align with frame boundaries, since most tasks don't\n  // need to be frame aligned; for those that do, use requestAnimationFrame.\n\n  var yieldInterval = 5;\n  var deadline = 0; // TODO: Make this configurable\n\n  {\n    // `isInputPending` is not available. Since we have no way of knowing if\n    // there's pending input, always yield at the end of the frame.\n    shouldYieldToHost = function () {\n      return exports.unstable_now() >= deadline;\n    }; // Since we yield every frame regardless, `requestPaint` has no effect.\n\n\n    requestPaint = function () {};\n  }\n\n  exports.unstable_forceFrameRate = function (fps) {\n    if (fps < 0 || fps > 125) {\n      // Using console['error'] to evade Babel and ESLint\n      console['error']('forceFrameRate takes a positive int between 0 and 125, ' + 'forcing framerates higher than 125 fps is not unsupported');\n      return;\n    }\n\n    if (fps > 0) {\n      yieldInterval = Math.floor(1000 / fps);\n    } else {\n      // reset the framerate\n      yieldInterval = 5;\n    }\n  };\n\n  var performWorkUntilDeadline = function () {\n    if (scheduledHostCallback !== null) {\n      var currentTime = exports.unstable_now(); // Yield after `yieldInterval` ms, regardless of where we are in the vsync\n      // cycle. This means there's always time remaining at the beginning of\n      // the message event.\n\n      deadline = currentTime + yieldInterval;\n      var hasTimeRemaining = true;\n\n      try {\n        var hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);\n\n        if (!hasMoreWork) {\n          isMessageLoopRunning = false;\n          scheduledHostCallback = null;\n        } else {\n          // If there's more work, schedule the next message event at the end\n          // of the preceding one.\n          port.postMessage(null);\n        }\n      } catch (error) {\n        // If a scheduler task throws, exit the current browser task so the\n        // error can be observed.\n        port.postMessage(null);\n        throw error;\n      }\n    } else {\n      isMessageLoopRunning = false;\n    } // Yielding to the browser will give it a chance to paint, so we can\n  };\n\n  var channel = new MessageChannel();\n  var port = channel.port2;\n  channel.port1.onmessage = performWorkUntilDeadline;\n\n  requestHostCallback = function (callback) {\n    scheduledHostCallback = callback;\n\n    if (!isMessageLoopRunning) {\n      isMessageLoopRunning = true;\n      port.postMessage(null);\n    }\n  };\n\n  requestHostTimeout = function (callback, ms) {\n    taskTimeoutID = _setTimeout(function () {\n      callback(exports.unstable_now());\n    }, ms);\n  };\n\n  cancelHostTimeout = function () {\n    _clearTimeout(taskTimeoutID);\n\n    taskTimeoutID = -1;\n  };\n}\n\nfunction push(heap, node) {\n  var index = heap.length;\n  heap.push(node);\n  siftUp(heap, node, index);\n}\nfunction peek(heap) {\n  var first = heap[0];\n  return first === undefined ? null : first;\n}\nfunction pop(heap) {\n  var first = heap[0];\n\n  if (first !== undefined) {\n    var last = heap.pop();\n\n    if (last !== first) {\n      heap[0] = last;\n      siftDown(heap, last, 0);\n    }\n\n    return first;\n  } else {\n    return null;\n  }\n}\n\nfunction siftUp(heap, node, i) {\n  var index = i;\n\n  while (true) {\n    var parentIndex = index - 1 >>> 1;\n    var parent = heap[parentIndex];\n\n    if (parent !== undefined && compare(parent, node) > 0) {\n      // The parent is larger. Swap positions.\n      heap[parentIndex] = node;\n      heap[index] = parent;\n      index = parentIndex;\n    } else {\n      // The parent is smaller. Exit.\n      return;\n    }\n  }\n}\n\nfunction siftDown(heap, node, i) {\n  var index = i;\n  var length = heap.length;\n\n  while (index < length) {\n    var leftIndex = (index + 1) * 2 - 1;\n    var left = heap[leftIndex];\n    var rightIndex = leftIndex + 1;\n    var right = heap[rightIndex]; // If the left or right node is smaller, swap with the smaller of those.\n\n    if (left !== undefined && compare(left, node) < 0) {\n      if (right !== undefined && compare(right, left) < 0) {\n        heap[index] = right;\n        heap[rightIndex] = node;\n        index = rightIndex;\n      } else {\n        heap[index] = left;\n        heap[leftIndex] = node;\n        index = leftIndex;\n      }\n    } else if (right !== undefined && compare(right, node) < 0) {\n      heap[index] = right;\n      heap[rightIndex] = node;\n      index = rightIndex;\n    } else {\n      // Neither child is smaller. Exit.\n      return;\n    }\n  }\n}\n\nfunction compare(a, b) {\n  // Compare sort index first, then task id.\n  var diff = a.sortIndex - b.sortIndex;\n  return diff !== 0 ? diff : a.id - b.id;\n}\n\n// TODO: Use symbols?\nvar NoPriority = 0;\nvar ImmediatePriority = 1;\nvar UserBlockingPriority = 2;\nvar NormalPriority = 3;\nvar LowPriority = 4;\nvar IdlePriority = 5;\n\nvar runIdCounter = 0;\nvar mainThreadIdCounter = 0;\nvar profilingStateSize = 4;\nvar sharedProfilingBuffer =  // $FlowFixMe Flow doesn't know about SharedArrayBuffer\ntypeof SharedArrayBuffer === 'function' ? new SharedArrayBuffer(profilingStateSize * Int32Array.BYTES_PER_ELEMENT) : // $FlowFixMe Flow doesn't know about ArrayBuffer\ntypeof ArrayBuffer === 'function' ? new ArrayBuffer(profilingStateSize * Int32Array.BYTES_PER_ELEMENT) : null // Don't crash the init path on IE9\n;\nvar profilingState =  sharedProfilingBuffer !== null ? new Int32Array(sharedProfilingBuffer) : []; // We can't read this but it helps save bytes for null checks\n\nvar PRIORITY = 0;\nvar CURRENT_TASK_ID = 1;\nvar CURRENT_RUN_ID = 2;\nvar QUEUE_SIZE = 3;\n\n{\n  profilingState[PRIORITY] = NoPriority; // This is maintained with a counter, because the size of the priority queue\n  // array might include canceled tasks.\n\n  profilingState[QUEUE_SIZE] = 0;\n  profilingState[CURRENT_TASK_ID] = 0;\n} // Bytes per element is 4\n\n\nvar INITIAL_EVENT_LOG_SIZE = 131072;\nvar MAX_EVENT_LOG_SIZE = 524288; // Equivalent to 2 megabytes\n\nvar eventLogSize = 0;\nvar eventLogBuffer = null;\nvar eventLog = null;\nvar eventLogIndex = 0;\nvar TaskStartEvent = 1;\nvar TaskCompleteEvent = 2;\nvar TaskErrorEvent = 3;\nvar TaskCancelEvent = 4;\nvar TaskRunEvent = 5;\nvar TaskYieldEvent = 6;\nvar SchedulerSuspendEvent = 7;\nvar SchedulerResumeEvent = 8;\n\nfunction logEvent(entries) {\n  if (eventLog !== null) {\n    var offset = eventLogIndex;\n    eventLogIndex += entries.length;\n\n    if (eventLogIndex + 1 > eventLogSize) {\n      eventLogSize *= 2;\n\n      if (eventLogSize > MAX_EVENT_LOG_SIZE) {\n        // Using console['error'] to evade Babel and ESLint\n        console['error'](\"Scheduler Profiling: Event log exceeded maximum size. Don't \" + 'forget to call `stopLoggingProfilingEvents()`.');\n        stopLoggingProfilingEvents();\n        return;\n      }\n\n      var newEventLog = new Int32Array(eventLogSize * 4);\n      newEventLog.set(eventLog);\n      eventLogBuffer = newEventLog.buffer;\n      eventLog = newEventLog;\n    }\n\n    eventLog.set(entries, offset);\n  }\n}\n\nfunction startLoggingProfilingEvents() {\n  eventLogSize = INITIAL_EVENT_LOG_SIZE;\n  eventLogBuffer = new ArrayBuffer(eventLogSize * 4);\n  eventLog = new Int32Array(eventLogBuffer);\n  eventLogIndex = 0;\n}\nfunction stopLoggingProfilingEvents() {\n  var buffer = eventLogBuffer;\n  eventLogSize = 0;\n  eventLogBuffer = null;\n  eventLog = null;\n  eventLogIndex = 0;\n  return buffer;\n}\nfunction markTaskStart(task, ms) {\n  {\n    profilingState[QUEUE_SIZE]++;\n\n    if (eventLog !== null) {\n      // performance.now returns a float, representing milliseconds. When the\n      // event is logged, it's coerced to an int. Convert to microseconds to\n      // maintain extra degrees of precision.\n      logEvent([TaskStartEvent, ms * 1000, task.id, task.priorityLevel]);\n    }\n  }\n}\nfunction markTaskCompleted(task, ms) {\n  {\n    profilingState[PRIORITY] = NoPriority;\n    profilingState[CURRENT_TASK_ID] = 0;\n    profilingState[QUEUE_SIZE]--;\n\n    if (eventLog !== null) {\n      logEvent([TaskCompleteEvent, ms * 1000, task.id]);\n    }\n  }\n}\nfunction markTaskCanceled(task, ms) {\n  {\n    profilingState[QUEUE_SIZE]--;\n\n    if (eventLog !== null) {\n      logEvent([TaskCancelEvent, ms * 1000, task.id]);\n    }\n  }\n}\nfunction markTaskErrored(task, ms) {\n  {\n    profilingState[PRIORITY] = NoPriority;\n    profilingState[CURRENT_TASK_ID] = 0;\n    profilingState[QUEUE_SIZE]--;\n\n    if (eventLog !== null) {\n      logEvent([TaskErrorEvent, ms * 1000, task.id]);\n    }\n  }\n}\nfunction markTaskRun(task, ms) {\n  {\n    runIdCounter++;\n    profilingState[PRIORITY] = task.priorityLevel;\n    profilingState[CURRENT_TASK_ID] = task.id;\n    profilingState[CURRENT_RUN_ID] = runIdCounter;\n\n    if (eventLog !== null) {\n      logEvent([TaskRunEvent, ms * 1000, task.id, runIdCounter]);\n    }\n  }\n}\nfunction markTaskYield(task, ms) {\n  {\n    profilingState[PRIORITY] = NoPriority;\n    profilingState[CURRENT_TASK_ID] = 0;\n    profilingState[CURRENT_RUN_ID] = 0;\n\n    if (eventLog !== null) {\n      logEvent([TaskYieldEvent, ms * 1000, task.id, runIdCounter]);\n    }\n  }\n}\nfunction markSchedulerSuspended(ms) {\n  {\n    mainThreadIdCounter++;\n\n    if (eventLog !== null) {\n      logEvent([SchedulerSuspendEvent, ms * 1000, mainThreadIdCounter]);\n    }\n  }\n}\nfunction markSchedulerUnsuspended(ms) {\n  {\n    if (eventLog !== null) {\n      logEvent([SchedulerResumeEvent, ms * 1000, mainThreadIdCounter]);\n    }\n  }\n}\n\n/* eslint-disable no-var */\n// Math.pow(2, 30) - 1\n// 0b111111111111111111111111111111\n\nvar maxSigned31BitInt = 1073741823; // Times out immediately\n\nvar IMMEDIATE_PRIORITY_TIMEOUT = -1; // Eventually times out\n\nvar USER_BLOCKING_PRIORITY = 250;\nvar NORMAL_PRIORITY_TIMEOUT = 5000;\nvar LOW_PRIORITY_TIMEOUT = 10000; // Never times out\n\nvar IDLE_PRIORITY = maxSigned31BitInt; // Tasks are stored on a min heap\n\nvar taskQueue = [];\nvar timerQueue = []; // Incrementing id counter. Used to maintain insertion order.\n\nvar taskIdCounter = 1; // Pausing the scheduler is useful for debugging.\nvar currentTask = null;\nvar currentPriorityLevel = NormalPriority; // This is set while performing work, to prevent re-entrancy.\n\nvar isPerformingWork = false;\nvar isHostCallbackScheduled = false;\nvar isHostTimeoutScheduled = false;\n\nfunction advanceTimers(currentTime) {\n  // Check for tasks that are no longer delayed and add them to the queue.\n  var timer = peek(timerQueue);\n\n  while (timer !== null) {\n    if (timer.callback === null) {\n      // Timer was cancelled.\n      pop(timerQueue);\n    } else if (timer.startTime <= currentTime) {\n      // Timer fired. Transfer to the task queue.\n      pop(timerQueue);\n      timer.sortIndex = timer.expirationTime;\n      push(taskQueue, timer);\n\n      {\n        markTaskStart(timer, currentTime);\n        timer.isQueued = true;\n      }\n    } else {\n      // Remaining timers are pending.\n      return;\n    }\n\n    timer = peek(timerQueue);\n  }\n}\n\nfunction handleTimeout(currentTime) {\n  isHostTimeoutScheduled = false;\n  advanceTimers(currentTime);\n\n  if (!isHostCallbackScheduled) {\n    if (peek(taskQueue) !== null) {\n      isHostCallbackScheduled = true;\n      requestHostCallback(flushWork);\n    } else {\n      var firstTimer = peek(timerQueue);\n\n      if (firstTimer !== null) {\n        requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\n      }\n    }\n  }\n}\n\nfunction flushWork(hasTimeRemaining, initialTime) {\n  {\n    markSchedulerUnsuspended(initialTime);\n  } // We'll need a host callback the next time work is scheduled.\n\n\n  isHostCallbackScheduled = false;\n\n  if (isHostTimeoutScheduled) {\n    // We scheduled a timeout but it's no longer needed. Cancel it.\n    isHostTimeoutScheduled = false;\n    cancelHostTimeout();\n  }\n\n  isPerformingWork = true;\n  var previousPriorityLevel = currentPriorityLevel;\n\n  try {\n    if (enableProfiling) {\n      try {\n        return workLoop(hasTimeRemaining, initialTime);\n      } catch (error) {\n        if (currentTask !== null) {\n          var currentTime = exports.unstable_now();\n          markTaskErrored(currentTask, currentTime);\n          currentTask.isQueued = false;\n        }\n\n        throw error;\n      }\n    } else {\n      // No catch in prod codepath.\n      return workLoop(hasTimeRemaining, initialTime);\n    }\n  } finally {\n    currentTask = null;\n    currentPriorityLevel = previousPriorityLevel;\n    isPerformingWork = false;\n\n    {\n      var _currentTime = exports.unstable_now();\n\n      markSchedulerSuspended(_currentTime);\n    }\n  }\n}\n\nfunction workLoop(hasTimeRemaining, initialTime) {\n  var currentTime = initialTime;\n  advanceTimers(currentTime);\n  currentTask = peek(taskQueue);\n\n  while (currentTask !== null && !(enableSchedulerDebugging )) {\n    if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost())) {\n      // This currentTask hasn't expired, and we've reached the deadline.\n      break;\n    }\n\n    var callback = currentTask.callback;\n\n    if (callback !== null) {\n      currentTask.callback = null;\n      currentPriorityLevel = currentTask.priorityLevel;\n      var didUserCallbackTimeout = currentTask.expirationTime <= currentTime;\n      markTaskRun(currentTask, currentTime);\n      var continuationCallback = callback(didUserCallbackTimeout);\n      currentTime = exports.unstable_now();\n\n      if (typeof continuationCallback === 'function') {\n        currentTask.callback = continuationCallback;\n        markTaskYield(currentTask, currentTime);\n      } else {\n        {\n          markTaskCompleted(currentTask, currentTime);\n          currentTask.isQueued = false;\n        }\n\n        if (currentTask === peek(taskQueue)) {\n          pop(taskQueue);\n        }\n      }\n\n      advanceTimers(currentTime);\n    } else {\n      pop(taskQueue);\n    }\n\n    currentTask = peek(taskQueue);\n  } // Return whether there's additional work\n\n\n  if (currentTask !== null) {\n    return true;\n  } else {\n    var firstTimer = peek(timerQueue);\n\n    if (firstTimer !== null) {\n      requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\n    }\n\n    return false;\n  }\n}\n\nfunction unstable_runWithPriority(priorityLevel, eventHandler) {\n  switch (priorityLevel) {\n    case ImmediatePriority:\n    case UserBlockingPriority:\n    case NormalPriority:\n    case LowPriority:\n    case IdlePriority:\n      break;\n\n    default:\n      priorityLevel = NormalPriority;\n  }\n\n  var previousPriorityLevel = currentPriorityLevel;\n  currentPriorityLevel = priorityLevel;\n\n  try {\n    return eventHandler();\n  } finally {\n    currentPriorityLevel = previousPriorityLevel;\n  }\n}\n\nfunction unstable_next(eventHandler) {\n  var priorityLevel;\n\n  switch (currentPriorityLevel) {\n    case ImmediatePriority:\n    case UserBlockingPriority:\n    case NormalPriority:\n      // Shift down to normal priority\n      priorityLevel = NormalPriority;\n      break;\n\n    default:\n      // Anything lower than normal priority should remain at the current level.\n      priorityLevel = currentPriorityLevel;\n      break;\n  }\n\n  var previousPriorityLevel = currentPriorityLevel;\n  currentPriorityLevel = priorityLevel;\n\n  try {\n    return eventHandler();\n  } finally {\n    currentPriorityLevel = previousPriorityLevel;\n  }\n}\n\nfunction unstable_wrapCallback(callback) {\n  var parentPriorityLevel = currentPriorityLevel;\n  return function () {\n    // This is a fork of runWithPriority, inlined for performance.\n    var previousPriorityLevel = currentPriorityLevel;\n    currentPriorityLevel = parentPriorityLevel;\n\n    try {\n      return callback.apply(this, arguments);\n    } finally {\n      currentPriorityLevel = previousPriorityLevel;\n    }\n  };\n}\n\nfunction timeoutForPriorityLevel(priorityLevel) {\n  switch (priorityLevel) {\n    case ImmediatePriority:\n      return IMMEDIATE_PRIORITY_TIMEOUT;\n\n    case UserBlockingPriority:\n      return USER_BLOCKING_PRIORITY;\n\n    case IdlePriority:\n      return IDLE_PRIORITY;\n\n    case LowPriority:\n      return LOW_PRIORITY_TIMEOUT;\n\n    case NormalPriority:\n    default:\n      return NORMAL_PRIORITY_TIMEOUT;\n  }\n}\n\nfunction unstable_scheduleCallback(priorityLevel, callback, options) {\n  var currentTime = exports.unstable_now();\n  var startTime;\n  var timeout;\n\n  if (typeof options === 'object' && options !== null) {\n    var delay = options.delay;\n\n    if (typeof delay === 'number' && delay > 0) {\n      startTime = currentTime + delay;\n    } else {\n      startTime = currentTime;\n    }\n\n    timeout = typeof options.timeout === 'number' ? options.timeout : timeoutForPriorityLevel(priorityLevel);\n  } else {\n    timeout = timeoutForPriorityLevel(priorityLevel);\n    startTime = currentTime;\n  }\n\n  var expirationTime = startTime + timeout;\n  var newTask = {\n    id: taskIdCounter++,\n    callback: callback,\n    priorityLevel: priorityLevel,\n    startTime: startTime,\n    expirationTime: expirationTime,\n    sortIndex: -1\n  };\n\n  {\n    newTask.isQueued = false;\n  }\n\n  if (startTime > currentTime) {\n    // This is a delayed task.\n    newTask.sortIndex = startTime;\n    push(timerQueue, newTask);\n\n    if (peek(taskQueue) === null && newTask === peek(timerQueue)) {\n      // All tasks are delayed, and this is the task with the earliest delay.\n      if (isHostTimeoutScheduled) {\n        // Cancel an existing timeout.\n        cancelHostTimeout();\n      } else {\n        isHostTimeoutScheduled = true;\n      } // Schedule a timeout.\n\n\n      requestHostTimeout(handleTimeout, startTime - currentTime);\n    }\n  } else {\n    newTask.sortIndex = expirationTime;\n    push(taskQueue, newTask);\n\n    {\n      markTaskStart(newTask, currentTime);\n      newTask.isQueued = true;\n    } // Schedule a host callback, if needed. If we're already performing work,\n    // wait until the next time we yield.\n\n\n    if (!isHostCallbackScheduled && !isPerformingWork) {\n      isHostCallbackScheduled = true;\n      requestHostCallback(flushWork);\n    }\n  }\n\n  return newTask;\n}\n\nfunction unstable_pauseExecution() {\n}\n\nfunction unstable_continueExecution() {\n\n  if (!isHostCallbackScheduled && !isPerformingWork) {\n    isHostCallbackScheduled = true;\n    requestHostCallback(flushWork);\n  }\n}\n\nfunction unstable_getFirstCallbackNode() {\n  return peek(taskQueue);\n}\n\nfunction unstable_cancelCallback(task) {\n  {\n    if (task.isQueued) {\n      var currentTime = exports.unstable_now();\n      markTaskCanceled(task, currentTime);\n      task.isQueued = false;\n    }\n  } // Null out the callback to indicate the task has been canceled. (Can't\n  // remove from the queue because you can't remove arbitrary nodes from an\n  // array based heap, only the first one.)\n\n\n  task.callback = null;\n}\n\nfunction unstable_getCurrentPriorityLevel() {\n  return currentPriorityLevel;\n}\n\nfunction unstable_shouldYield() {\n  var currentTime = exports.unstable_now();\n  advanceTimers(currentTime);\n  var firstTask = peek(taskQueue);\n  return firstTask !== currentTask && currentTask !== null && firstTask !== null && firstTask.callback !== null && firstTask.startTime <= currentTime && firstTask.expirationTime < currentTask.expirationTime || shouldYieldToHost();\n}\n\nvar unstable_requestPaint = requestPaint;\nvar unstable_Profiling =  {\n  startLoggingProfilingEvents: startLoggingProfilingEvents,\n  stopLoggingProfilingEvents: stopLoggingProfilingEvents,\n  sharedProfilingBuffer: sharedProfilingBuffer\n} ;\n\nexports.unstable_IdlePriority = IdlePriority;\nexports.unstable_ImmediatePriority = ImmediatePriority;\nexports.unstable_LowPriority = LowPriority;\nexports.unstable_NormalPriority = NormalPriority;\nexports.unstable_Profiling = unstable_Profiling;\nexports.unstable_UserBlockingPriority = UserBlockingPriority;\nexports.unstable_cancelCallback = unstable_cancelCallback;\nexports.unstable_continueExecution = unstable_continueExecution;\nexports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;\nexports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;\nexports.unstable_next = unstable_next;\nexports.unstable_pauseExecution = unstable_pauseExecution;\nexports.unstable_requestPaint = unstable_requestPaint;\nexports.unstable_runWithPriority = unstable_runWithPriority;\nexports.unstable_scheduleCallback = unstable_scheduleCallback;\nexports.unstable_shouldYield = unstable_shouldYield;\nexports.unstable_wrapCallback = unstable_wrapCallback;\n  })();\n}\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./cjs/scheduler.production.min.js');\n} else {\n  module.exports = require('./cjs/scheduler.development.js');\n}\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./cjs/scheduler-tracing.production.min.js');\n} else {\n  module.exports = require('./cjs/scheduler-tracing.development.js');\n}\n"],"names":["interactionIDCounter","threadIDCounter","exports","__interactionsRef","__subscriberRef","current","Set","subscribers","onInteractionTraced","interaction","didCatchError","caughtError","forEach","subscriber","error","onInteractionScheduledWorkCompleted","onWorkScheduled","interactions","threadID","onWorkStarted","onWorkStopped","onWorkCanceled","unstable_clear","callback","prevInteractions","unstable_getCurrent","unstable_getThreadID","unstable_subscribe","add","size","unstable_trace","name","timestamp","arguments","length","undefined","__count","id","returnValue","unstable_unsubscribe","delete","unstable_wrap","wrappedInteractions","hasRun","wrapped","apply","cancel","requestHostCallback","requestHostTimeout","cancelHostTimeout","shouldYieldToHost","requestPaint","window","MessageChannel","_callback","_timeoutID","_flushCallback","currentTime","unstable_now","e","setTimeout","initialTime","Date","now","cb","ms","clearTimeout","unstable_forceFrameRate","performance","_Date","_setTimeout","_clearTimeout","console","requestAnimationFrame","cancelAnimationFrame","_initialTime","isMessageLoopRunning","scheduledHostCallback","taskTimeoutID","yieldInterval","deadline","fps","Math","floor","channel","port","port2","port1","onmessage","postMessage","push","heap","node","index","i","parentIndex","parent","compare","siftUp","peek","first","pop","last","leftIndex","left","rightIndex","right","siftDown","a","b","diff","sortIndex","runIdCounter","mainThreadIdCounter","sharedProfilingBuffer","SharedArrayBuffer","Int32Array","BYTES_PER_ELEMENT","ArrayBuffer","profilingState","eventLogSize","eventLogBuffer","eventLog","eventLogIndex","logEvent","entries","offset","stopLoggingProfilingEvents","newEventLog","set","buffer","markTaskStart","task","priorityLevel","markTaskCompleted","markTaskYield","taskQueue","timerQueue","taskIdCounter","currentTask","currentPriorityLevel","isPerformingWork","isHostCallbackScheduled","isHostTimeoutScheduled","advanceTimers","timer","startTime","expirationTime","isQueued","handleTimeout","flushWork","firstTimer","hasTimeRemaining","previousPriorityLevel","didUserCallbackTimeout","continuationCallback","workLoop","markTaskErrored","markSchedulerSuspended","timeoutForPriorityLevel","unstable_requestPaint","unstable_Profiling","startLoggingProfilingEvents","unstable_IdlePriority","unstable_ImmediatePriority","unstable_LowPriority","unstable_NormalPriority","unstable_UserBlockingPriority","unstable_cancelCallback","markTaskCanceled","unstable_continueExecution","unstable_getCurrentPriorityLevel","unstable_getFirstCallbackNode","unstable_next","eventHandler","unstable_pauseExecution","unstable_runWithPriority","unstable_scheduleCallback","options","timeout","delay","newTask","unstable_shouldYield","firstTask","unstable_wrapCallback","parentPriorityLevel","this","module"],"sourceRoot":""}